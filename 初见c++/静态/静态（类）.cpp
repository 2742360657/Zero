#include<iostream>
struct bzd1
{
	int x, y;
	void xie1()//非静态方法会默认调用当前类的实例（this指针），而静态方法则不会
	{
		std::cout << x << y << std::endl;
	}
};
struct bzd2
{
	static int x, y;
	void xie2()//非静态成员函数默认情况下不能直接访问静态成员变量，因为静态成员变量不属于类的任何特定实例。
		       //它们是类级别的变量，因此应该通过类名来访问，而不是通过实例。然而，这并不会导致编译错误，因
		       //为编译器允许你声明这样的函数，只是当你尝试在不使用类名的情况下访问静态变量时，编译器会报错。
		       //如果代码能够正常运行，那么可能是因为没有在非静态成员函数中直接访问静态成员变量，或者你的编译
		       //器 / 链接器配置允许了某些通常不被推荐的做法。
	{
		std::cout << x << y << std::endl;
	}
};
struct bzd3
{
	static int x, y;
	static void xie3()//此时正常工作，因为静态方法调用了静态变量
	{
		std::cout << x << y << std::endl;
	}
};
struct bzd4//静态方法在类内外无区别（即属于类，但不属于实例），因为静态方法无法调用当前类的实例，所以类对其无影响，所以“xie4”写到外面也无影响
{
	int x, y;
	static void xie4(bzd4 bzd4_1)//静态方法无法访问非静态变量,如果写法同上会报错（无法调用x与y），
		                         //所以它需要一个 bzd4 类型的参数来访问非静态成员变量 x 和 y
	{
		std::cout << bzd4_1.x << bzd4_1.y << std::endl;
	}
};

//此处不能使用"int bzd::x;"，因为非静态数据成员不能在其类的外部定义

int bzd2::x;//静态数据成员需要在其类的外部定义，不定义会报错
int bzd2::y;//此处更像是命名空间的用法

int main()
{
	/*
	创建 bzd1、bzd2 和 bzd4 结构体的实例。
	调用非静态成员函数和静态成员函数。
	对于 bzd1，每个实例都有自己的 x 和 y 值。
	对于 bzd2，所有实例共享相同的 x 和 y 值。
	对于 bzd4，静态成员函数 xie4 需要一个 bzd4 类型的参数来访问非静态成员变量。
	*/
	bzd1 bzd1_1;
	bzd1_1.x = 1;
	bzd1_1.y = 2;
	bzd1 bzd1_2;
	bzd1_2.x = 5;
	bzd1_2.y = 8;
	bzd1_1.xie1();
	bzd1_2.xie1();//分别输出12与58，因为非静态变量可以重新赋值
	bzd2 bzd2_1;
	bzd2_1.x = 1;//实际上正确的静态成员变量的赋值应该是"bzd2::x=1(因为值唯一，没有实例）"，下同
	bzd2_1.y = 1;
	bzd2_1.x = 2;//可以在同一个"实例"（其实不是实例，静态变量没有实例）中重新赋值，此时输出会输出21
	bzd2 bzd2_2;
	bzd2_2.x = 3;//此处实际上是更改了之前的"实例"的值，静态变量值是唯一的（只分配了一处内存），相当于是类内的全局变量
	bzd2_2.y = 4;
	bzd2_1.xie2();
	bzd2_2.xie2();//两次都会输出34
	bzd4 bzd4_1;
	bzd4_1.x = 7;
	bzd4_1.y = 2;
	bzd4_1.xie4(bzd4_1);//此处由于方法是静态的，必须在"()"内输入调用内容，空置会报错
}


